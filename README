Tcl/Tk Go bindings.

In its current state the bindings are a bit Tk-oriented. You can't create an
interpreter instance without Tk. In future it's likely it will be changed.

The API is very simple. In the package you have one type and one function:

type Interpreter struct
func NewInterpreter (init interface{}) *Interpreter

In order to launch an interpreter you have to call the "NewInterpreter"
function, it will make a new instance of a tcl/tk interpreter in a separate
goroutine, execute "init", block in Tk's main loop and then the function
returns a pointer to the new instance of an "Interpreter".

"init" could be a string with tcl commands that are executed before Tk's main
loop, or a function with this signature: "func (*Interpreter)". This function
gets executed the same way as the string, that is - before Tk's main loop.

Here are the methods of the "Interpreter":

func (*Interpreter) Eval(args ...interface{})
func (*Interpreter) EvalAsString(args ...interface{}) string
func (*Interpreter) EvalAsInt(args ...interface{}) int
func (*Interpreter) EvalAsFloat(args ...interface{}) float64
func (*Interpreter) UploadImage(name string, img image.Image)
func (*Interpreter) RegisterCommand(name string, cbfunc interface{})
func (*Interpreter) UnregisterCommand(name string)
func (*Interpreter) RegisterChannel(name string, ch interface{})
func (*Interpreter) UnregisterChannel(name string)
func (*Interpreter) Sync()

As it was stated before, the "Interpreter" is being executed in a separate
goroutine and each method is completely thread-safe. Also every method that
doesn't return anything is asynchronous (except Sync). Basically it puts the
method and its args to the interpreter's queue and at some point in future the
method will be executed. If you call method A and then method B, method A will
be always executed before method B, but both methods will be executed at some
point in future.

You can explicitly wait for a completion of all previously queued calls by
using the Sync method.

There is an exception however, each method acts synchronously in case if it's
executed in the interpreter's thread. It may happen for example when you pass
an initialization function to the "NewInterpreter" or if you do method calls in
a registered tcl command that was called from an interpreter.

That's it. See "examples" directory it has the use cases for most of the API.
